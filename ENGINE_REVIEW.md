# Engine algorithm review

This note summarizes improvement ideas for the engines' trading logic and supporting helpers.

## Mean reversion (HBAR/DOGE)
- **Persist history & warm-up behavior:** `ratio_history` only lives in memory, so restarts discard context and the bot immediately trades once the minimum samples accumulate during the current process. Persisting a rolling window (or backfilling from `PriceSnapshot`) would make signals consistent across restarts and avoid reacting to a cold start.【F:engines/mean_reversion.py†L14-L155】
- **Signal symmetry / exits:** The config exposes `z_exit` but the loop only uses the entry threshold. Implementing exit hysteresis (e.g., require |z| < z_exit before re-arming) would reduce whipsaws and keep the position logic aligned with the config.【F:engines/mean_reversion.py†L25-L36】【F:engines/mean_reversion.py†L383-L472】
- **Trade sizing & risk:** The strategy trades either full balance or a fixed notional, but it ignores Binance `MIN_NOTIONAL` filters and slippage. Introducing a notional clamp based on filters and passing an explicit quote quantity (or price cap) to market orders would avoid rejects or unexpectedly small fills.【F:engines/mean_reversion.py†L305-L378】【F:engines/mean_reversion.py†L100-L116】
- **PNL bookkeeping:** Trades record zero fees and zero PnL, and state PnL is never updated after rotations. Calculating realized PnL from filled quantities and incorporating a configurable fee rate would make the state table meaningful for monitoring.【F:engines/mean_reversion.py†L424-L459】
- **Thread lifecycle:** The worker thread is daemonized and only gated by a stop flag; it is never joined and keeps running when the app is imported. Moving startup/shutdown into FastAPI lifespan hooks and joining with a timeout would prevent orphaned DB sessions in tests or reloads.【F:engines/mean_reversion.py†L17-L21】【F:engines/mean_reversion.py†L383-L487】

## Bollinger bands
- **Band calculation & reuse:** The helper duplicates the mean/std logic from the MR engine. Centralizing the calculation (and optionally switching to incremental stats) would keep behavior consistent and simplify testing.【F:engines/bollinger.py†L112-L119】【F:engines/mean_reversion.py†L265-L281】
- **Stop/TP enforcement:** Stop-loss and take-profit are checked only when a long position exists; a buy triggered at the lower band can immediately violate those levels on the same tick without being filtered. Adding pre-trade guards against oversized percentage drops/gains would avoid entering into obviously invalid states.【F:engines/bollinger.py†L195-L213】
- **Quantity & capital controls:** Orders are sized solely via `LOT_SIZE`; `MIN_NOTIONAL` is ignored, so buys and sells can still be rejected. Incorporating notional validation and reserving a safety buffer from `quote_bal` would reduce failures.【F:engines/bollinger.py†L214-L285】【F:engines/bollinger.py†L78-L88】
- **Position reconciliation:** Sells rely on the current free base balance, not the recorded `qty_asset`, so partial fills or external transfers can desynchronize state. Reconciling state with actual positions (and clamping to available balance before deciding an action) would keep realized PnL accurate.【F:engines/bollinger.py†L242-L288】

## Shared trade handling
- **Partial fills & order feedback:** The MR engine tries to infer filled quote from `cummulativeQuoteQty`, but the Bollinger path assumes full fills at the requested qty. Standardizing on filled quantities from order responses (and retrying or resizing on partials) would make both strategies more resilient.【F:engines/mean_reversion.py†L287-L378】【F:engines/bollinger.py†L214-L288】
- **Fee/slippage awareness:** Neither engine models fees or slippage, so the recorded PnL can be optimistic. Applying a configurable fee rate, price protection (e.g., a max slippage percent), and storing the actual fill price(s) would yield more realistic performance metrics.【F:engines/mean_reversion.py†L424-L459】【F:engines/bollinger.py†L214-L288】
- **Cooldowns & duplicate trades:** Bollinger uses a cooldown, but MR does not; both rely on timing and shared globals, which can race if multiple trade triggers occur before DB commits. Introducing per-symbol debouncing and idempotent trade records (e.g., via unique request IDs) would prevent double entries during transient errors.【F:engines/mean_reversion.py†L383-L472】【F:engines/bollinger.py†L189-L193】
